/**
 * File generated by Jenny -- https://github.com/LanderlYoung/Jenny
 *
 * For bug report, please refer to github issue tracker https://github.com/LanderlYoung/Jenny/issues.
 */
#include "Native.h"
#include <SFML/Audio.hpp>
#include <assert.h>


/*
 * Class:     io.eontimer.audio.Sound$Native
 * Method:    public static final void allocate$eon_timer_audio(java.nio.LongBuffer buffer)
 * Signature: (Ljava/nio/LongBuffer;)V
 */
void Native::allocate$eon_timer_audio(JNIEnv *env, jclass clazz, jobject buffer) {
    auto *address = (jlong *) env->GetDirectBufferAddress(buffer);
    address[0] = (jlong) new sf::Sound();
    void (*deleter)(jlong) = [](jlong ptr) { delete (sf::Sound *) ptr; };
    address[1] = (jlong) deleter;
}

/*
 * Class:     io.eontimer.audio.Sound$Native
 * Method:    public static final void load$eon_timer_audio(long rawAddress, java.nio.ByteBuffer buffer)
 * Signature: (JLjava/nio/ByteBuffer;)V
 */
void Native::load$eon_timer_audio(JNIEnv *env, jclass clazz, jlong rawAddress, jobject buffer) {
    auto *sound = (sf::Sound *) rawAddress;
    auto *soundBuffer = new sf::SoundBuffer();
    soundBuffer->loadFromMemory(env->GetDirectBufferAddress(buffer), env->GetDirectBufferCapacity(buffer));
    sound->setBuffer(*soundBuffer);
}

/*
 * Class:     io.eontimer.audio.Sound$Native
 * Method:    public static final void play$eon_timer_audio(long rawAddress)
 * Signature: (J)V
 */
void Native::play$eon_timer_audio(JNIEnv *env, jclass clazz, jlong rawAddress) {
    ((sf::Sound *) rawAddress)->play();
}

JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) {
    JNIEnv *env;
    if (vm->GetEnv(reinterpret_cast<void **>(&env), JNI_VERSION_1_8) != JNI_OK) {
        return -1;
    }
    assert(Native::registerNativeFunctions(env));
    return JNI_VERSION_1_8;
}




